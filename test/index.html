<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link rel="stylesheet" href="./css/index.css">
  <link as="script" rel="preload" href="./js/index1.js">
  <link as="script" rel="preload" href="./js/index.js">
  <!-- <style>
    .red {
      color: red;
    }
    .div {
      display: block;
      border: 1px solid red;
    }
  </style> -->
</head>
<body>
  <!-- <link rel="stylesheet" href="./css/index1.css"> -->
  <p class="blue">上面这段描述就是Recalculate Style包括 CSS 的解析和 CSSOM 的构建，还包括一些递归的样式计算（例如计算父元素大小时需要先递归计算子元素的大小）。但是我在实验中却发现 CSS 解析和 CSSOM 构建准确来说发生在Parse HTML和Parse Stylesheet中。因此，我更愿意把它以字面意思理解，也就是一些样式的计算。</p>
  <p>上面这段描述就是Recalculate Style包括 CSS 的解析和 CSSOM 的构建，还包括一些递归的样式计算（例如计算父元素大小时需要先递归计算子元素的大小）。但是我在实验中却发现 CSS 解析和 CSSOM 构建准确来说发生在Parse HTML和Parse Stylesheet中。因此，我更愿意把它以字面意思理解，也就是一些样式的计算。</p>
  <p>上面这段描述就是Recalculate Style包括 CSS 的解析和 CSSOM 的构建，还包括一些递归的样式计算（例如计算父元素大小时需要先递归计算子元素的大小）。但是我在实验中却发现 CSS 解析和 CSSOM 构建准确来说发生在Parse HTML和Parse Stylesheet中。因此，我更愿意把它以字面意思理解，也就是一些样式的计算。</p>
  <div class="content content-red"></div>
  <button id="btn">确认</button>
  <script>
    (function () {
      var b = document.querySelector('body');
      var ss = ['./js/index1.js', './js/index.js'];
      ss.forEach(function (s) {
        var p = document.createElement('script');
        p.type = 'text/javascript';
        p.src = s;
        p.async = false;
        p.defer = true;
        b.appendChild(p)
      })
    })()
  </script>
  <!-- <script src="./js/index1.js"></script> -->
  <!-- <script src="./js/index.js"></script> -->
</body>
</html>